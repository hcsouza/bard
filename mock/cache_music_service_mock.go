package mock

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/hcsouza/bard/cache.CacheMusicService -o ./cache_music_service_mock_test.go

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/hcsouza/bard/music"
)

// CacheMusicServiceMock implements CacheMusicService
type CacheMusicServiceMock struct {
	t minimock.Tester

	funcAddTracksByCountryAndGenre          func(s1 string, s2 string, p1 music.Playlist) (err error)
	inspectFuncAddTracksByCountryAndGenre   func(s1 string, s2 string, p1 music.Playlist)
	afterAddTracksByCountryAndGenreCounter  uint64
	beforeAddTracksByCountryAndGenreCounter uint64
	AddTracksByCountryAndGenreMock          mCacheMusicServiceMockAddTracksByCountryAndGenre

	funcTracksByCountryAndGenre          func(s1 string, s2 string) (p1 music.Playlist, err error)
	inspectFuncTracksByCountryAndGenre   func(s1 string, s2 string)
	afterTracksByCountryAndGenreCounter  uint64
	beforeTracksByCountryAndGenreCounter uint64
	TracksByCountryAndGenreMock          mCacheMusicServiceMockTracksByCountryAndGenre
}

// NewCacheMusicServiceMock returns a mock for CacheMusicService
func NewCacheMusicServiceMock(t minimock.Tester) *CacheMusicServiceMock {
	m := &CacheMusicServiceMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddTracksByCountryAndGenreMock = mCacheMusicServiceMockAddTracksByCountryAndGenre{mock: m}
	m.AddTracksByCountryAndGenreMock.callArgs = []*CacheMusicServiceMockAddTracksByCountryAndGenreParams{}

	m.TracksByCountryAndGenreMock = mCacheMusicServiceMockTracksByCountryAndGenre{mock: m}
	m.TracksByCountryAndGenreMock.callArgs = []*CacheMusicServiceMockTracksByCountryAndGenreParams{}

	return m
}

type mCacheMusicServiceMockAddTracksByCountryAndGenre struct {
	mock               *CacheMusicServiceMock
	defaultExpectation *CacheMusicServiceMockAddTracksByCountryAndGenreExpectation
	expectations       []*CacheMusicServiceMockAddTracksByCountryAndGenreExpectation

	callArgs []*CacheMusicServiceMockAddTracksByCountryAndGenreParams
	mutex    sync.RWMutex
}

// CacheMusicServiceMockAddTracksByCountryAndGenreExpectation specifies expectation struct of the CacheMusicService.AddTracksByCountryAndGenre
type CacheMusicServiceMockAddTracksByCountryAndGenreExpectation struct {
	mock    *CacheMusicServiceMock
	params  *CacheMusicServiceMockAddTracksByCountryAndGenreParams
	results *CacheMusicServiceMockAddTracksByCountryAndGenreResults
	Counter uint64
}

// CacheMusicServiceMockAddTracksByCountryAndGenreParams contains parameters of the CacheMusicService.AddTracksByCountryAndGenre
type CacheMusicServiceMockAddTracksByCountryAndGenreParams struct {
	s1 string
	s2 string
	p1 music.Playlist
}

// CacheMusicServiceMockAddTracksByCountryAndGenreResults contains results of the CacheMusicService.AddTracksByCountryAndGenre
type CacheMusicServiceMockAddTracksByCountryAndGenreResults struct {
	err error
}

// Expect sets up expected params for CacheMusicService.AddTracksByCountryAndGenre
func (mmAddTracksByCountryAndGenre *mCacheMusicServiceMockAddTracksByCountryAndGenre) Expect(s1 string, s2 string, p1 music.Playlist) *mCacheMusicServiceMockAddTracksByCountryAndGenre {
	if mmAddTracksByCountryAndGenre.mock.funcAddTracksByCountryAndGenre != nil {
		mmAddTracksByCountryAndGenre.mock.t.Fatalf("CacheMusicServiceMock.AddTracksByCountryAndGenre mock is already set by Set")
	}

	if mmAddTracksByCountryAndGenre.defaultExpectation == nil {
		mmAddTracksByCountryAndGenre.defaultExpectation = &CacheMusicServiceMockAddTracksByCountryAndGenreExpectation{}
	}

	mmAddTracksByCountryAndGenre.defaultExpectation.params = &CacheMusicServiceMockAddTracksByCountryAndGenreParams{s1, s2, p1}
	for _, e := range mmAddTracksByCountryAndGenre.expectations {
		if minimock.Equal(e.params, mmAddTracksByCountryAndGenre.defaultExpectation.params) {
			mmAddTracksByCountryAndGenre.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddTracksByCountryAndGenre.defaultExpectation.params)
		}
	}

	return mmAddTracksByCountryAndGenre
}

// Inspect accepts an inspector function that has same arguments as the CacheMusicService.AddTracksByCountryAndGenre
func (mmAddTracksByCountryAndGenre *mCacheMusicServiceMockAddTracksByCountryAndGenre) Inspect(f func(s1 string, s2 string, p1 music.Playlist)) *mCacheMusicServiceMockAddTracksByCountryAndGenre {
	if mmAddTracksByCountryAndGenre.mock.inspectFuncAddTracksByCountryAndGenre != nil {
		mmAddTracksByCountryAndGenre.mock.t.Fatalf("Inspect function is already set for CacheMusicServiceMock.AddTracksByCountryAndGenre")
	}

	mmAddTracksByCountryAndGenre.mock.inspectFuncAddTracksByCountryAndGenre = f

	return mmAddTracksByCountryAndGenre
}

// Return sets up results that will be returned by CacheMusicService.AddTracksByCountryAndGenre
func (mmAddTracksByCountryAndGenre *mCacheMusicServiceMockAddTracksByCountryAndGenre) Return(err error) *CacheMusicServiceMock {
	if mmAddTracksByCountryAndGenre.mock.funcAddTracksByCountryAndGenre != nil {
		mmAddTracksByCountryAndGenre.mock.t.Fatalf("CacheMusicServiceMock.AddTracksByCountryAndGenre mock is already set by Set")
	}

	if mmAddTracksByCountryAndGenre.defaultExpectation == nil {
		mmAddTracksByCountryAndGenre.defaultExpectation = &CacheMusicServiceMockAddTracksByCountryAndGenreExpectation{mock: mmAddTracksByCountryAndGenre.mock}
	}
	mmAddTracksByCountryAndGenre.defaultExpectation.results = &CacheMusicServiceMockAddTracksByCountryAndGenreResults{err}
	return mmAddTracksByCountryAndGenre.mock
}

//Set uses given function f to mock the CacheMusicService.AddTracksByCountryAndGenre method
func (mmAddTracksByCountryAndGenre *mCacheMusicServiceMockAddTracksByCountryAndGenre) Set(f func(s1 string, s2 string, p1 music.Playlist) (err error)) *CacheMusicServiceMock {
	if mmAddTracksByCountryAndGenre.defaultExpectation != nil {
		mmAddTracksByCountryAndGenre.mock.t.Fatalf("Default expectation is already set for the CacheMusicService.AddTracksByCountryAndGenre method")
	}

	if len(mmAddTracksByCountryAndGenre.expectations) > 0 {
		mmAddTracksByCountryAndGenre.mock.t.Fatalf("Some expectations are already set for the CacheMusicService.AddTracksByCountryAndGenre method")
	}

	mmAddTracksByCountryAndGenre.mock.funcAddTracksByCountryAndGenre = f
	return mmAddTracksByCountryAndGenre.mock
}

// When sets expectation for the CacheMusicService.AddTracksByCountryAndGenre which will trigger the result defined by the following
// Then helper
func (mmAddTracksByCountryAndGenre *mCacheMusicServiceMockAddTracksByCountryAndGenre) When(s1 string, s2 string, p1 music.Playlist) *CacheMusicServiceMockAddTracksByCountryAndGenreExpectation {
	if mmAddTracksByCountryAndGenre.mock.funcAddTracksByCountryAndGenre != nil {
		mmAddTracksByCountryAndGenre.mock.t.Fatalf("CacheMusicServiceMock.AddTracksByCountryAndGenre mock is already set by Set")
	}

	expectation := &CacheMusicServiceMockAddTracksByCountryAndGenreExpectation{
		mock:   mmAddTracksByCountryAndGenre.mock,
		params: &CacheMusicServiceMockAddTracksByCountryAndGenreParams{s1, s2, p1},
	}
	mmAddTracksByCountryAndGenre.expectations = append(mmAddTracksByCountryAndGenre.expectations, expectation)
	return expectation
}

// Then sets up CacheMusicService.AddTracksByCountryAndGenre return parameters for the expectation previously defined by the When method
func (e *CacheMusicServiceMockAddTracksByCountryAndGenreExpectation) Then(err error) *CacheMusicServiceMock {
	e.results = &CacheMusicServiceMockAddTracksByCountryAndGenreResults{err}
	return e.mock
}

// AddTracksByCountryAndGenre implements CacheMusicService
func (mmAddTracksByCountryAndGenre *CacheMusicServiceMock) AddTracksByCountryAndGenre(s1 string, s2 string, p1 music.Playlist) (err error) {
	mm_atomic.AddUint64(&mmAddTracksByCountryAndGenre.beforeAddTracksByCountryAndGenreCounter, 1)
	defer mm_atomic.AddUint64(&mmAddTracksByCountryAndGenre.afterAddTracksByCountryAndGenreCounter, 1)

	if mmAddTracksByCountryAndGenre.inspectFuncAddTracksByCountryAndGenre != nil {
		mmAddTracksByCountryAndGenre.inspectFuncAddTracksByCountryAndGenre(s1, s2, p1)
	}

	mm_params := &CacheMusicServiceMockAddTracksByCountryAndGenreParams{s1, s2, p1}

	// Record call args
	mmAddTracksByCountryAndGenre.AddTracksByCountryAndGenreMock.mutex.Lock()
	mmAddTracksByCountryAndGenre.AddTracksByCountryAndGenreMock.callArgs = append(mmAddTracksByCountryAndGenre.AddTracksByCountryAndGenreMock.callArgs, mm_params)
	mmAddTracksByCountryAndGenre.AddTracksByCountryAndGenreMock.mutex.Unlock()

	for _, e := range mmAddTracksByCountryAndGenre.AddTracksByCountryAndGenreMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddTracksByCountryAndGenre.AddTracksByCountryAndGenreMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddTracksByCountryAndGenre.AddTracksByCountryAndGenreMock.defaultExpectation.Counter, 1)
		mm_want := mmAddTracksByCountryAndGenre.AddTracksByCountryAndGenreMock.defaultExpectation.params
		mm_got := CacheMusicServiceMockAddTracksByCountryAndGenreParams{s1, s2, p1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddTracksByCountryAndGenre.t.Errorf("CacheMusicServiceMock.AddTracksByCountryAndGenre got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddTracksByCountryAndGenre.AddTracksByCountryAndGenreMock.defaultExpectation.results
		if mm_results == nil {
			mmAddTracksByCountryAndGenre.t.Fatal("No results are set for the CacheMusicServiceMock.AddTracksByCountryAndGenre")
		}
		return (*mm_results).err
	}
	if mmAddTracksByCountryAndGenre.funcAddTracksByCountryAndGenre != nil {
		return mmAddTracksByCountryAndGenre.funcAddTracksByCountryAndGenre(s1, s2, p1)
	}
	mmAddTracksByCountryAndGenre.t.Fatalf("Unexpected call to CacheMusicServiceMock.AddTracksByCountryAndGenre. %v %v %v", s1, s2, p1)
	return
}

// AddTracksByCountryAndGenreAfterCounter returns a count of finished CacheMusicServiceMock.AddTracksByCountryAndGenre invocations
func (mmAddTracksByCountryAndGenre *CacheMusicServiceMock) AddTracksByCountryAndGenreAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddTracksByCountryAndGenre.afterAddTracksByCountryAndGenreCounter)
}

// AddTracksByCountryAndGenreBeforeCounter returns a count of CacheMusicServiceMock.AddTracksByCountryAndGenre invocations
func (mmAddTracksByCountryAndGenre *CacheMusicServiceMock) AddTracksByCountryAndGenreBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddTracksByCountryAndGenre.beforeAddTracksByCountryAndGenreCounter)
}

// Calls returns a list of arguments used in each call to CacheMusicServiceMock.AddTracksByCountryAndGenre.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddTracksByCountryAndGenre *mCacheMusicServiceMockAddTracksByCountryAndGenre) Calls() []*CacheMusicServiceMockAddTracksByCountryAndGenreParams {
	mmAddTracksByCountryAndGenre.mutex.RLock()

	argCopy := make([]*CacheMusicServiceMockAddTracksByCountryAndGenreParams, len(mmAddTracksByCountryAndGenre.callArgs))
	copy(argCopy, mmAddTracksByCountryAndGenre.callArgs)

	mmAddTracksByCountryAndGenre.mutex.RUnlock()

	return argCopy
}

// MinimockAddTracksByCountryAndGenreDone returns true if the count of the AddTracksByCountryAndGenre invocations corresponds
// the number of defined expectations
func (m *CacheMusicServiceMock) MinimockAddTracksByCountryAndGenreDone() bool {
	for _, e := range m.AddTracksByCountryAndGenreMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddTracksByCountryAndGenreMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddTracksByCountryAndGenreCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddTracksByCountryAndGenre != nil && mm_atomic.LoadUint64(&m.afterAddTracksByCountryAndGenreCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddTracksByCountryAndGenreInspect logs each unmet expectation
func (m *CacheMusicServiceMock) MinimockAddTracksByCountryAndGenreInspect() {
	for _, e := range m.AddTracksByCountryAndGenreMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheMusicServiceMock.AddTracksByCountryAndGenre with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddTracksByCountryAndGenreMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddTracksByCountryAndGenreCounter) < 1 {
		if m.AddTracksByCountryAndGenreMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheMusicServiceMock.AddTracksByCountryAndGenre")
		} else {
			m.t.Errorf("Expected call to CacheMusicServiceMock.AddTracksByCountryAndGenre with params: %#v", *m.AddTracksByCountryAndGenreMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddTracksByCountryAndGenre != nil && mm_atomic.LoadUint64(&m.afterAddTracksByCountryAndGenreCounter) < 1 {
		m.t.Error("Expected call to CacheMusicServiceMock.AddTracksByCountryAndGenre")
	}
}

type mCacheMusicServiceMockTracksByCountryAndGenre struct {
	mock               *CacheMusicServiceMock
	defaultExpectation *CacheMusicServiceMockTracksByCountryAndGenreExpectation
	expectations       []*CacheMusicServiceMockTracksByCountryAndGenreExpectation

	callArgs []*CacheMusicServiceMockTracksByCountryAndGenreParams
	mutex    sync.RWMutex
}

// CacheMusicServiceMockTracksByCountryAndGenreExpectation specifies expectation struct of the CacheMusicService.TracksByCountryAndGenre
type CacheMusicServiceMockTracksByCountryAndGenreExpectation struct {
	mock    *CacheMusicServiceMock
	params  *CacheMusicServiceMockTracksByCountryAndGenreParams
	results *CacheMusicServiceMockTracksByCountryAndGenreResults
	Counter uint64
}

// CacheMusicServiceMockTracksByCountryAndGenreParams contains parameters of the CacheMusicService.TracksByCountryAndGenre
type CacheMusicServiceMockTracksByCountryAndGenreParams struct {
	s1 string
	s2 string
}

// CacheMusicServiceMockTracksByCountryAndGenreResults contains results of the CacheMusicService.TracksByCountryAndGenre
type CacheMusicServiceMockTracksByCountryAndGenreResults struct {
	p1  music.Playlist
	err error
}

// Expect sets up expected params for CacheMusicService.TracksByCountryAndGenre
func (mmTracksByCountryAndGenre *mCacheMusicServiceMockTracksByCountryAndGenre) Expect(s1 string, s2 string) *mCacheMusicServiceMockTracksByCountryAndGenre {
	if mmTracksByCountryAndGenre.mock.funcTracksByCountryAndGenre != nil {
		mmTracksByCountryAndGenre.mock.t.Fatalf("CacheMusicServiceMock.TracksByCountryAndGenre mock is already set by Set")
	}

	if mmTracksByCountryAndGenre.defaultExpectation == nil {
		mmTracksByCountryAndGenre.defaultExpectation = &CacheMusicServiceMockTracksByCountryAndGenreExpectation{}
	}

	mmTracksByCountryAndGenre.defaultExpectation.params = &CacheMusicServiceMockTracksByCountryAndGenreParams{s1, s2}
	for _, e := range mmTracksByCountryAndGenre.expectations {
		if minimock.Equal(e.params, mmTracksByCountryAndGenre.defaultExpectation.params) {
			mmTracksByCountryAndGenre.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTracksByCountryAndGenre.defaultExpectation.params)
		}
	}

	return mmTracksByCountryAndGenre
}

// Inspect accepts an inspector function that has same arguments as the CacheMusicService.TracksByCountryAndGenre
func (mmTracksByCountryAndGenre *mCacheMusicServiceMockTracksByCountryAndGenre) Inspect(f func(s1 string, s2 string)) *mCacheMusicServiceMockTracksByCountryAndGenre {
	if mmTracksByCountryAndGenre.mock.inspectFuncTracksByCountryAndGenre != nil {
		mmTracksByCountryAndGenre.mock.t.Fatalf("Inspect function is already set for CacheMusicServiceMock.TracksByCountryAndGenre")
	}

	mmTracksByCountryAndGenre.mock.inspectFuncTracksByCountryAndGenre = f

	return mmTracksByCountryAndGenre
}

// Return sets up results that will be returned by CacheMusicService.TracksByCountryAndGenre
func (mmTracksByCountryAndGenre *mCacheMusicServiceMockTracksByCountryAndGenre) Return(p1 music.Playlist, err error) *CacheMusicServiceMock {
	if mmTracksByCountryAndGenre.mock.funcTracksByCountryAndGenre != nil {
		mmTracksByCountryAndGenre.mock.t.Fatalf("CacheMusicServiceMock.TracksByCountryAndGenre mock is already set by Set")
	}

	if mmTracksByCountryAndGenre.defaultExpectation == nil {
		mmTracksByCountryAndGenre.defaultExpectation = &CacheMusicServiceMockTracksByCountryAndGenreExpectation{mock: mmTracksByCountryAndGenre.mock}
	}
	mmTracksByCountryAndGenre.defaultExpectation.results = &CacheMusicServiceMockTracksByCountryAndGenreResults{p1, err}
	return mmTracksByCountryAndGenre.mock
}

//Set uses given function f to mock the CacheMusicService.TracksByCountryAndGenre method
func (mmTracksByCountryAndGenre *mCacheMusicServiceMockTracksByCountryAndGenre) Set(f func(s1 string, s2 string) (p1 music.Playlist, err error)) *CacheMusicServiceMock {
	if mmTracksByCountryAndGenre.defaultExpectation != nil {
		mmTracksByCountryAndGenre.mock.t.Fatalf("Default expectation is already set for the CacheMusicService.TracksByCountryAndGenre method")
	}

	if len(mmTracksByCountryAndGenre.expectations) > 0 {
		mmTracksByCountryAndGenre.mock.t.Fatalf("Some expectations are already set for the CacheMusicService.TracksByCountryAndGenre method")
	}

	mmTracksByCountryAndGenre.mock.funcTracksByCountryAndGenre = f
	return mmTracksByCountryAndGenre.mock
}

// When sets expectation for the CacheMusicService.TracksByCountryAndGenre which will trigger the result defined by the following
// Then helper
func (mmTracksByCountryAndGenre *mCacheMusicServiceMockTracksByCountryAndGenre) When(s1 string, s2 string) *CacheMusicServiceMockTracksByCountryAndGenreExpectation {
	if mmTracksByCountryAndGenre.mock.funcTracksByCountryAndGenre != nil {
		mmTracksByCountryAndGenre.mock.t.Fatalf("CacheMusicServiceMock.TracksByCountryAndGenre mock is already set by Set")
	}

	expectation := &CacheMusicServiceMockTracksByCountryAndGenreExpectation{
		mock:   mmTracksByCountryAndGenre.mock,
		params: &CacheMusicServiceMockTracksByCountryAndGenreParams{s1, s2},
	}
	mmTracksByCountryAndGenre.expectations = append(mmTracksByCountryAndGenre.expectations, expectation)
	return expectation
}

// Then sets up CacheMusicService.TracksByCountryAndGenre return parameters for the expectation previously defined by the When method
func (e *CacheMusicServiceMockTracksByCountryAndGenreExpectation) Then(p1 music.Playlist, err error) *CacheMusicServiceMock {
	e.results = &CacheMusicServiceMockTracksByCountryAndGenreResults{p1, err}
	return e.mock
}

// TracksByCountryAndGenre implements CacheMusicService
func (mmTracksByCountryAndGenre *CacheMusicServiceMock) TracksByCountryAndGenre(s1 string, s2 string) (p1 music.Playlist, err error) {
	mm_atomic.AddUint64(&mmTracksByCountryAndGenre.beforeTracksByCountryAndGenreCounter, 1)
	defer mm_atomic.AddUint64(&mmTracksByCountryAndGenre.afterTracksByCountryAndGenreCounter, 1)

	if mmTracksByCountryAndGenre.inspectFuncTracksByCountryAndGenre != nil {
		mmTracksByCountryAndGenre.inspectFuncTracksByCountryAndGenre(s1, s2)
	}

	mm_params := &CacheMusicServiceMockTracksByCountryAndGenreParams{s1, s2}

	// Record call args
	mmTracksByCountryAndGenre.TracksByCountryAndGenreMock.mutex.Lock()
	mmTracksByCountryAndGenre.TracksByCountryAndGenreMock.callArgs = append(mmTracksByCountryAndGenre.TracksByCountryAndGenreMock.callArgs, mm_params)
	mmTracksByCountryAndGenre.TracksByCountryAndGenreMock.mutex.Unlock()

	for _, e := range mmTracksByCountryAndGenre.TracksByCountryAndGenreMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmTracksByCountryAndGenre.TracksByCountryAndGenreMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTracksByCountryAndGenre.TracksByCountryAndGenreMock.defaultExpectation.Counter, 1)
		mm_want := mmTracksByCountryAndGenre.TracksByCountryAndGenreMock.defaultExpectation.params
		mm_got := CacheMusicServiceMockTracksByCountryAndGenreParams{s1, s2}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTracksByCountryAndGenre.t.Errorf("CacheMusicServiceMock.TracksByCountryAndGenre got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTracksByCountryAndGenre.TracksByCountryAndGenreMock.defaultExpectation.results
		if mm_results == nil {
			mmTracksByCountryAndGenre.t.Fatal("No results are set for the CacheMusicServiceMock.TracksByCountryAndGenre")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmTracksByCountryAndGenre.funcTracksByCountryAndGenre != nil {
		return mmTracksByCountryAndGenre.funcTracksByCountryAndGenre(s1, s2)
	}
	mmTracksByCountryAndGenre.t.Fatalf("Unexpected call to CacheMusicServiceMock.TracksByCountryAndGenre. %v %v", s1, s2)
	return
}

// TracksByCountryAndGenreAfterCounter returns a count of finished CacheMusicServiceMock.TracksByCountryAndGenre invocations
func (mmTracksByCountryAndGenre *CacheMusicServiceMock) TracksByCountryAndGenreAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTracksByCountryAndGenre.afterTracksByCountryAndGenreCounter)
}

// TracksByCountryAndGenreBeforeCounter returns a count of CacheMusicServiceMock.TracksByCountryAndGenre invocations
func (mmTracksByCountryAndGenre *CacheMusicServiceMock) TracksByCountryAndGenreBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTracksByCountryAndGenre.beforeTracksByCountryAndGenreCounter)
}

// Calls returns a list of arguments used in each call to CacheMusicServiceMock.TracksByCountryAndGenre.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTracksByCountryAndGenre *mCacheMusicServiceMockTracksByCountryAndGenre) Calls() []*CacheMusicServiceMockTracksByCountryAndGenreParams {
	mmTracksByCountryAndGenre.mutex.RLock()

	argCopy := make([]*CacheMusicServiceMockTracksByCountryAndGenreParams, len(mmTracksByCountryAndGenre.callArgs))
	copy(argCopy, mmTracksByCountryAndGenre.callArgs)

	mmTracksByCountryAndGenre.mutex.RUnlock()

	return argCopy
}

// MinimockTracksByCountryAndGenreDone returns true if the count of the TracksByCountryAndGenre invocations corresponds
// the number of defined expectations
func (m *CacheMusicServiceMock) MinimockTracksByCountryAndGenreDone() bool {
	for _, e := range m.TracksByCountryAndGenreMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TracksByCountryAndGenreMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTracksByCountryAndGenreCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTracksByCountryAndGenre != nil && mm_atomic.LoadUint64(&m.afterTracksByCountryAndGenreCounter) < 1 {
		return false
	}
	return true
}

// MinimockTracksByCountryAndGenreInspect logs each unmet expectation
func (m *CacheMusicServiceMock) MinimockTracksByCountryAndGenreInspect() {
	for _, e := range m.TracksByCountryAndGenreMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheMusicServiceMock.TracksByCountryAndGenre with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TracksByCountryAndGenreMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTracksByCountryAndGenreCounter) < 1 {
		if m.TracksByCountryAndGenreMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheMusicServiceMock.TracksByCountryAndGenre")
		} else {
			m.t.Errorf("Expected call to CacheMusicServiceMock.TracksByCountryAndGenre with params: %#v", *m.TracksByCountryAndGenreMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTracksByCountryAndGenre != nil && mm_atomic.LoadUint64(&m.afterTracksByCountryAndGenreCounter) < 1 {
		m.t.Error("Expected call to CacheMusicServiceMock.TracksByCountryAndGenre")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CacheMusicServiceMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddTracksByCountryAndGenreInspect()

		m.MinimockTracksByCountryAndGenreInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CacheMusicServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CacheMusicServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddTracksByCountryAndGenreDone() &&
		m.MinimockTracksByCountryAndGenreDone()
}
